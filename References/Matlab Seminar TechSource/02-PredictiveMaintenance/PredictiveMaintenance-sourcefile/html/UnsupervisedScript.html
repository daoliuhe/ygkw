
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Unsupervised Analysis for Predictive Maintenance</title><meta name="generator" content="MATLAB 9.0"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-03-15"><meta name="DC.source" content="UnsupervisedScript.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Unsupervised Analysis for Predictive Maintenance</h1><!--introduction--><p>One common situation is when our equipment maintenance schedule is very conservative, resulting in none of the equipment experiencing failures. Many organizations may choose this approach if failures are particularly costly, but this can often lead to waste as maintenance may be performed more often than required. If we do not have real-world data for what failure looks like, then we have 2 options:</p><div><ul><li>Create a high fidelity model and inject failures to gather data, potentially for use in a supervised learning workflow</li><li>Use unsupervised learning on the data to create a warning system for when behavior is deviating from normal</li></ul></div><p>This script focuses on the second option.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Story setup</a></li><li><a href="#2">Read in first engine data</a></li><li><a href="#3">View subset of sensor signals</a></li><li><a href="#4">Select relevant variable names based on visualization</a></li><li><a href="#5">Remove noise</a></li><li><a href="#6">Plot smoothed data</a></li><li><a href="#7">Monitoring equipment - control charts</a></li><li><a href="#8">Read all data</a></li><li><a href="#9">Plot all data</a></li><li><a href="#10">Standardize data</a></li><li><a href="#11">Dimensionality Reduction - PCA</a></li><li><a href="#12">What do higher principal components look like?</a></li><li><a href="#13">Warning system</a></li><li><a href="#14">Visualize first and last points for each engine</a></li><li><a href="#16">Highlight problematic engines</a></li><li><a href="#17">Animation of path through PCA</a></li><li><a href="#18">Initial criteria for warning and alarm signals</a></li><li><a href="#19">How can we evaluate the criteria?</a></li><li><a href="#20">Evaluate all engines to failure</a></li><li><a href="#21">How much uptime did we gain?</a></li></ul></div><h2>Story setup<a name="1"></a></h2><p>We've acquired a fleet of 100 aircraft engines. The manufacturer recommends that we perform maintenace after every 125 flights. After our first round of maintenance, our maintenance workers tell us that only engines 39, 57, 70, and 91 were badly in need of maintenance. The others seemed fine and could have run longer without servicing. This means we are wasting money by doing maintenance more often than needed. We'd like to develop a better way to identify when servicing is needed so we can be smarter about scheduling our maintenance.</p><h2>Read in first engine data<a name="2"></a></h2><p>The data used is the sensor readings taken off of the equipment. Maintenance was done after 125 flights, regardless of whether the equipment seemed to need it or not, so we only have the first 125 flights off of each engine. We have data from 100 engines, each stored in a separate file. We'll start by looking at just one data file for engine 1.</p><pre class="codeinput"><span class="comment">% read in data</span>
sensorData = readtable(<span class="string">'engine1Unsupervised.csv'</span>,<span class="string">'ReadVariableNames'</span>,true);
</pre><h2>View subset of sensor signals<a name="3"></a></h2><p>We have a total 21 sensors for each engine. Since that's a lot to put on the screen at once, let's look at just the first nine sensors. We can see that some of them are flat, so they won't be useful for understanding how the condition of the system is changing. Others need a bit of smoothing to remove some noise. The other 12 sensors we are not looking at here behave similarly.</p><pre class="codeinput">figure
<span class="keyword">for</span> ii = 1:9
    subplot(3,3,ii)
    plot(sensorData.Time,sensorData{:,5+ii})
    title(sensorData.Properties.VariableNames{5+ii})
    xlabel(<span class="string">'Time'</span>)
    xlim([0,125])
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_01.png" style="width:560px;height:420px;" alt=""> <h2>Select relevant variable names based on visualization<a name="4"></a></h2><p>Here we select the variables we want to keep, getting rid of the sensors that were flat and unuseful.</p><pre class="codeinput">variableNames = {<span class="string">'Unit'</span> <span class="string">'Time'</span> <span class="string">'LPCOutletTemp'</span> <span class="string">'HPCOutletTemp'</span> <span class="keyword">...</span>
    <span class="string">'LPTOutletTemp'</span> <span class="string">'TotalHPCOutletPres'</span> <span class="string">'PhysFanSpeed'</span> <span class="keyword">...</span>
    <span class="string">'PhysCoreSpeed'</span> <span class="string">'StaticHPCOutletPres'</span> <span class="string">'FuelFlowRatio'</span><span class="keyword">...</span>
    <span class="string">'CorrFanSpeed'</span> <span class="string">'CorrCoreSpeed'</span> <span class="string">'BypassRatio'</span><span class="keyword">...</span>
    <span class="string">'BleedEnthalpy'</span> <span class="string">'HPTCoolantBleed'</span> <span class="string">'LPTCoolantBleed'</span>};
sensorData = sensorData(:, variableNames);
</pre><h2>Remove noise<a name="5"></a></h2><p>There is some amount of noise in the signal. There are many advanced methods in MATLAB to identify and remove noise. Here we simply use a trailing moving average filter to smooth the signals slightly.</p><pre class="codeinput"><span class="comment">% Filter configuration</span>
filterWindow = 5;
b = (1/filterWindow)*ones(1,filterWindow);
a = 1;
<span class="comment">% Filter sensor data</span>
smoothData = sensorData;
smoothData{:,3:end} = filter(b,a,sensorData{:,3:end});
smoothData(1:5,:) = [];
</pre><h2>Plot smoothed data<a name="6"></a></h2><p>We are down to 14 sensors from 21 after removing the sensors that were constant signals. After smoothing the remaining signals, we can now see the signals we have to work with.</p><pre class="codeinput">figure
<span class="keyword">for</span> ii = 1:9
    subplot(3,3,ii)
    plot(smoothData.Time,smoothData{:,5+ii})
    title(smoothData.Properties.VariableNames{5+ii})
    xlabel(<span class="string">'Time'</span>)
    xlim([0,125])
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_02.png" style="width:560px;height:420px;" alt=""> <h2>Monitoring equipment - control charts<a name="7"></a></h2><p>How can we use these signals to determine if the equipment is in normal coniditions? One common method is using what is called a control chart. As long as our signal stays within the upper and lower control limits, we might consider it normal conditions. If the signals goes outside the limits, then we might have a problem.</p><p>However when we have a large number of signals, such as the 14 we have here, it is difficult to determine when we might have a problem. Is one sensor going outside the bounds for 1 point a problem? 5 sensors for 3 points? 10 sensors for 20 points? Control charts become difficult to use in these cases, so we will bring in machine learning to help us.</p><pre class="codeinput">controlchart(sensorData.LPCOutletTemp,<span class="string">'chart'</span>,<span class="string">'i'</span>)
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_03.png" style="width:560px;height:420px;" alt=""> <h2>Read all data<a name="8"></a></h2><p>Before we try using machine learning, let's read in all the data we have available. Our data files are stored in a single folder, with each of the hundred engines stored in a separate file. We will use a datastore to easily read them all in.</p><pre class="codeinput"><span class="comment">% enter the file names with wildcard character * or ?</span>
filenames = <span class="string">'train_FD001_Unit_*'</span>;
files = [pwd <span class="string">'\Data\'</span> filenames <span class="string">'.csv'</span>];
<span class="comment">% set up the data store</span>
ds = datastore(files,<span class="string">'TreatAsMissing'</span>,<span class="string">'NA'</span>,<span class="string">'Delimiter'</span>, <span class="string">','</span>,<span class="keyword">...</span>
    <span class="string">'SelectedVariableNames'</span>,variableNames,<span class="string">'ReadSize'</span>,<span class="string">'file'</span>);
<span class="comment">% read all the data from the datastore</span>
dataAll = readall(ds);
<span class="comment">% apply the moving average filter one engine at a time</span>
smoothDataAll = filterData(b,a,dataAll,125);
</pre><h2>Plot all data<a name="9"></a></h2><p>Now we can visualize all 100 engines plotted on top of each other. We can now see that there is not a clear signal over time, but rather a range of values that the sensors could take.</p><pre class="codeinput">figure
<span class="keyword">for</span> ii = 1:9
    subplot(3,3,ii)
    plot(smoothDataAll.Time,smoothDataAll{:,5+ii},<span class="string">'.'</span>)
    title(smoothDataAll.Properties.VariableNames{5+ii})
    xlabel(<span class="string">'Time'</span>)
    xlim([0,125])
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_04.png" style="width:560px;height:420px;" alt=""> <h2>Standardize data<a name="10"></a></h2><p>Many machine learning techniques, such as PCA, involve measuring distances between points. However machine learning algorithms do not understand concepts like units. Since the data is recorded with different scales and units we need to standardize the data in some way. There are many different ways we might standardize data based on its properties and our analysis goals. Just as one example, here we give each signal the same mean of zero and standard deviation of one.</p><pre class="codeinput"><span class="comment">% Pull out just the sensor data, ignoring the unit and timestamp</span>
Xtrain = smoothDataAll{:,3:end};
<span class="comment">% Give all sensors mean of zero and standard deviation of one</span>
XtrainMean = mean(Xtrain);
XtrainStd = std(Xtrain);
XtrainStandard = (Xtrain - repmat(XtrainMean,length(Xtrain),1))./<span class="keyword">...</span>
    repmat(XtrainStd,length(Xtrain),1);
</pre><h2>Dimensionality Reduction - PCA<a name="11"></a></h2><p>Principal component analysis (PCA) is one of the most popular methods of reducing the dimensionality of the data by rotating our axes such that they point in the directions of maximum variance. This allows us to summarize a large portion of the data in a smaller dimensional data set. In this case, note that the first two principal components capture a good portion of the variance in the dataset but further principal components only capture a small amount of additional information.</p><pre class="codeinput"><span class="comment">% apply principal components analysis to the standardized data</span>
[coeff,score,latent] = pca(XtrainStandard);

<span class="comment">% plot the total variance explained by each individual principal component</span>
<span class="comment">% along with the cumulative total that has been explained</span>
figure
plot([cumsum(latent(1:10))/sum(latent) latent(1:10)/sum(latent)]*100,<span class="string">'.'</span>,<span class="keyword">...</span>
    <span class="string">'MarkerSize'</span>,18)
xlabel(<span class="string">'# of principal component'</span>);
ylabel(<span class="string">'% of variance of dataset explained'</span>);
legend(<span class="string">'Cumulative'</span>,<span class="string">'Individual'</span>)
title(<span class="string">'Individual and Cumulative Variance Explained by PCA'</span>)
grid <span class="string">on</span>

<span class="comment">% visualize the first 2 principal components, which explain nearly 90% of</span>
<span class="comment">% the overall variance</span>
figure
plot(score(:,1),score(:,2),<span class="string">'.'</span>)
xlabel(<span class="string">'First Principal Component'</span>)
ylabel(<span class="string">'Second Principal Component'</span>)

<span class="comment">% Save the needed variables to standardize new data and transform it into</span>
<span class="comment">% the same PCA projection</span>
save <span class="string">cordTrans</span> <span class="string">coeff</span> <span class="string">XtrainMean</span> <span class="string">XtrainStd</span>
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_05.png" style="width:560px;height:420px;" alt=""> <img vspace="5" hspace="5" src="UnsupervisedScript_06.png" style="width:560px;height:420px;" alt=""> <h2>What do higher principal components look like?<a name="12"></a></h2><p>In this case the higher principal components only contain a very small amount of information. If we project our data onto the third and fourth principal components, as seen below, it looks like they contain only normally distributed random noise. This holds true for all higher principal components as well.</p><pre class="codeinput">figure
scatter(score(:,3),score(:,4));
xlabel(<span class="string">'Third Principal Component'</span>)
ylabel(<span class="string">'Fourth Principal Component'</span>)
title(<span class="string">'4th vs 3rd Principal Component'</span>)
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_07.png" style="width:560px;height:420px;" alt=""> <h2>Warning system<a name="13"></a></h2><p>Now we need to find some way to use this group of points to determine when conditions are deviating away from 'normal'. A common approach is to call the region that contains densely packed points 'normal' conditions, and the small number of points that fall outside of them to be 'abnormal' and potentially in need of maintenance. We need some way to determine when an engine might transition from 'normal' to 'abnormal' behavior.</p><h2>Visualize first and last points for each engine<a name="14"></a></h2><p>As a first try we can simply look at the first and last point recorded for each engine. If engines tend to start in a certain area of the PCA, but move to a different area by the time maintenance is performed, this may give us some indication of what the trend towards failure looks like.</p><p>In this case we can see that the first and last points form two groups, with the first points centered closer to the origin and the last points centered further away. However there is significant overlap between them, which would not be surprising if many engines are still behaving normally at the time maintenance was performed.</p><pre class="codeinput"><span class="comment">% Find first and last point for each engine</span>
[~,idxEng] = unique(smoothDataAll.Unit);
idxEngLast = idxEng-1;
idxEngLast(idxEngLast &lt; 1) = [];

<span class="comment">% Compute centroids</span>
idxEngCent = [mean(score(idxEng,1)),mean(score(idxEng,2))];
idxEngLastCent = [mean(score(idxEngLast,1)),mean(score(idxEngLast,2))];

<span class="comment">% Plot data</span>
figure; hold <span class="string">on</span>
plot(score(idxEng,1),score(idxEng,2),<span class="string">'.'</span>,<span class="string">'MarkerSize'</span>,16)
plot(score(idxEngLast,1),score(idxEngLast,2),<span class="string">'r.'</span>,<span class="string">'MarkerSize'</span>,16)
scatter(idxEngCent(1),idxEngCent(2),50,<span class="string">'g'</span>,<span class="string">'^'</span>,<span class="string">'filled'</span>)
scatter(idxEngLastCent(1),idxEngLastCent(2),50,<span class="string">'g'</span>,<span class="string">'o'</span>,<span class="string">'filled'</span>)
hold <span class="string">off</span>
legend(<span class="string">'First Points'</span>,<span class="string">'Last Points'</span>,<span class="string">'First Points Centroid'</span>,<span class="keyword">...</span>
    <span class="string">'Last Points Centroid'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>)
xlabel(<span class="string">'First Principal Component'</span>)
ylabel(<span class="string">'Second Principal Component'</span>)
title(<span class="string">'First (Sample 1) and Last (Sample 125) for Each Engine'</span>)
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_08.png" style="width:560px;height:420px;" alt=""> <h2>Highlight problematic engines<a name="16"></a></h2><p>The prior plot showed much overlap between the first and last data points. However some of the last data points clearly fall well outside the main cluster. Our maintenance staff identified several engines that had showed signs of degredation. Here we can show the points just from these engines as they approach their maintenance date to see if they show any clear trends. They are plotted on top of all other points to see how they may be different.</p><p>We can see that many of them do indeed fall outside the main cluster of points, indicating that if an engine's sensor readings move outside the main cluster it may make for a good criteria for when an engine needs servicing.</p><pre class="codeinput">idx = ismember(smoothDataAll.Unit,[39, 57, 70, 91]);
idx = idx &amp; smoothDataAll.Time &gt; (max(smoothDataAll.Time)-20); <span class="comment">% only last 20 cycles</span>
figure; hold <span class="string">on</span>;
plot(score(:,1),score(:,2),<span class="string">'.'</span>)
plot(score(idx,1),score(idx,2),<span class="string">'r.'</span>)
hold <span class="string">off</span>
xlabel(<span class="string">'First Principal Component'</span>)
ylabel(<span class="string">'Second Principal Component'</span>)
title(<span class="string">'Last 20 Flights of Problematic Engines Shown in Red'</span>)
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_09.png" style="width:560px;height:420px;" alt=""> <h2>Animation of path through PCA<a name="17"></a></h2><p>For further investigation we can see how different engines move through the cluster of data points as they approach their maintenance date.</p><pre class="codeinput"><span class="comment">% Engines identified by maintenance: [39, 57, 70, 91]</span>
EngineNum = 39;
r = find(smoothDataAll.Unit == EngineNum);
figure; hold <span class="string">on</span>
pall = plot(score(:,1),score(:,2),<span class="string">'.'</span>);
peng = plot(score(r(1),1), score(r(1),2),<span class="string">'g-'</span>,<span class="string">'LineWidth'</span>,2);
pcur = plot(score(r(1),1), score(r(1),2),<span class="string">'go'</span>,<span class="string">'MarkerFaceColor'</span>,<span class="string">'r'</span>);
ti = title([<span class="string">'Engine '</span> num2str(EngineNum) <span class="string">' Sample 1'</span>]);
xlabel(<span class="string">'First Principal Component'</span>)
ylabel(<span class="string">'Second Principal Component'</span>)
hold <span class="string">off</span>
<span class="keyword">for</span> ii = 1:length(r)
    set(peng,<span class="string">'XData'</span>,score(r(1:ii),1),<span class="string">'YData'</span>,score(r(1:ii),2))
    set(pcur,<span class="string">'XData'</span>,score(r(ii),1),<span class="string">'YData'</span>,score(r(ii),2))
    ti.String = [<span class="string">'Engine Number '</span> num2str(EngineNum) <span class="string">' Sample '</span> num2str(ii+4)];
    pause(0.1)
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_10.png" style="width:560px;height:420px;" alt=""> <h2>Initial criteria for warning and alarm signals<a name="18"></a></h2><p>Based on the results, we can make an initial guess for the criteria to use for when to issue a 'warning' or 'alarm' signal. Clearly all engines begin within the main cluster of points. It seems that they may move outside of the cluster as servicing becomes more needed. We will generate a 'warn' result when the engine behavior has left 'normal' conditions (in this case 'normal' includes about 90% of the data) and should be prioritized for maintenance. An 'alarm' means that this engine is very far from 'normal' and may need maintenance urgently. Below is one example of an initial guess we may make for where to draw the line between the 'normal', 'warn', and 'alarm' regions.</p><p>The criteria for producing the 'warn' and 'alarm' signals should be treated as initial guesses that will continue to evolve over time as we perform more rounds of maintenance while gathering more sensor data and maintenance feedback.</p><pre class="codeinput">idxAlarm = score(:,1) &gt; 10 | score(:,1) &lt; -7 | score(:,2) &gt; 5 | score(:,2) &lt; -4;
idxWarn = score(:,1) &gt; 5 | score(:,1) &lt; -6.5 | score(:,2) &gt; 2 | score(:,2) &lt; -3 <span class="keyword">...</span>
    &amp; ~idxAlarm;

figure; hold <span class="string">on</span>
patch([-10;-10;15;15;10;10;-7;-7;-10],<span class="keyword">...</span>
    [-4,8,8,-4,-4,5,5,-4,-4],<span class="string">'r'</span>,<span class="string">'FaceAlpha'</span>,0.3)
patch([-7,-7,10,10,5,5,-6.5,-6.5,4.99,4.99,-6.5],<span class="keyword">...</span>
    [-4,5,5,-4,-4,2,2,-3,-3,-4,-4],<span class="string">'y'</span>,<span class="string">'FaceColor'</span>,[1 .8 0],<span class="string">'FaceAlpha'</span>,0.3)
patch([-6.5,-6.5,5,5,-6.5],[-3,2,2,-3,-3],<span class="string">'g'</span>,<span class="string">'FaceAlpha'</span>,0.3)
plot(score(:,1),score(:,2),<span class="string">'.'</span>)
hold <span class="string">off</span>
title(<span class="string">'Green = Normal, Orange = Warning, Red = Alarm'</span>)
xlabel(<span class="string">'First Principal Component'</span>)
ylabel(<span class="string">'Second Principal Component'</span>)

fprintf(<span class="string">'\nPercent of points captured by ''normal'' conditions: %.1f%% \n'</span>,sum(~idxWarn)/length(score)*100)
fprintf(<span class="string">'Percent of points captured by ''normal'' + ''warn'' conditions: %.1f%% \n'</span>,sum(~idxAlarm)/length(score)*100)
</pre><pre class="codeoutput">
Percent of points captured by 'normal' conditions: 90.0% 
Percent of points captured by 'normal' + 'warn' conditions: 99.5% 
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_11.png" style="width:560px;height:420px;" alt=""> <h2>How can we evaluate the criteria?<a name="19"></a></h2><p>Since we have never had an equipment failure, we have no way of knowing what failure looks like in the data. Even though our maintenance staff identified several engines that appeared to be degrading, and those engines appeared to show a distinct trend closer to the maintenance date, we still don't know how close to failure they actually were. So then how can we use this information to improve our decision making? This is one of the most difficult aspects of unsupervised learning.</p><p>There are a number of strategies for how to use these results. One conservative strategy is to slowly roll back the regularly scheduled maintenance dates. For example, this data came from our first round of maintenance. On the next maintenance round, we might wait to perform maintenance until equipment cycle 135 instead of 125, unless a piece of equipment signals an 'alarm'. If it does, we could prioritize maintenance for that piece of equipment. Otherwise, we will wait longer than the last time to do scheduled maintenance. Along the way we can use the additional sensor data and feedback from maintenance to update our 'warn' and 'alarm' criteria.</p><p>We can continue to roll back the pace of our regularly scheduled maintenance dates, until we are scheduling our maintenance entirely based on when we get the 'warn' and 'alarm' signals from our equipment. If a failure does occur in spite of our efforts, SAVE THAT DATA! Real world data leading up to and including failure is both very valuable and very expensive to gather. The better we can understand what failure looks like in the data, the better our results can get.</p><h2>Evaluate all engines to failure<a name="20"></a></h2><p>We actually do have data from all 100 engines running until failure conditions are reached, we were just ignoring what happened after sample 125 so we could explore an unsupervised workflow in a scheduled maintenance situation. Here we load in all the data from all 100 engines to determine how this would have turned out if we ran all our engines to failure while tracking their warning and alarm signals.</p><p>We can see how as the engines approach failure the ratios of 'normal', 'warning' and 'alarm' classifications change over time. All engines are 'normal' until around 125 flights prior to failure, at which point some begin to enter the 'warning' region. Around 75 flights prior to failure, some befin to enter the 'alarm' region. All engines have left 'normal' conditions by 26 flights prior to failure. By 9 flights prior to failure, all 100 engines are triggering alarms, so no engine enters failure without triggering an alarm for at least 9 consecutive flights.</p><pre class="codeinput"><span class="comment">% load in full dataset</span>
load <span class="string">fullDataset</span>
load <span class="string">cordTrans</span>
<span class="comment">% extract and standardize full sensor data</span>
Xfull = fullDataset{:,3:end-2};
Xfull = (Xfull - repmat(XtrainMean,length(Xfull),1))./repmat(XtrainStd,length(Xfull),1);
<span class="comment">% project full sensor data onto principal coordinates</span>
score = Xfull*coeff;
<span class="comment">% classify each point into 'normal', 'warning', and 'alarm'</span>
idxAlarm = score(:,1) &gt; 10 | score(:,1) &lt; -7 | score(:,2) &gt; 5 | score(:,2) &lt; -4;
idxWarn = (score(:,1) &gt; 5 | score(:,1) &lt; -6.5 | score(:,2) &gt; 2 | score(:,2) &lt; -3) &amp; ~idxAlarm;
idxNorm = ~idxWarn &amp; ~idxAlarm;
<span class="comment">% group by time before failure, and determine which percentage of the</span>
<span class="comment">% engines were being classified into each group at each point in time</span>
[g,r] = findgroups(fullDataset.Time2);
s = splitapply(@(n,w,a)[sum(n)/length(n),sum(w)/length(w),sum(a)/length(a)],idxNorm,idxWarn,idxAlarm,g);
<span class="comment">% plot data</span>
figure
hold <span class="string">on</span>
plot(r,s(:,1),<span class="string">'g'</span>,<span class="string">'LineWidth'</span>,2)
plot(r,s(:,2),<span class="string">'Color'</span>,[1 .8 0],<span class="string">'LineWidth'</span>,2)
plot(r,s(:,3),<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2)
legend(<span class="string">'Normal'</span>,<span class="string">'Warning'</span>,<span class="string">'Alarm'</span>,<span class="string">'Location'</span>,<span class="string">'NorthWest'</span>)
xlabel(<span class="string">'Flights Prior to Failure'</span>)
ylabel(<span class="string">'Fraction of Engines'</span>)
grid <span class="string">on</span>
hold <span class="string">off</span>
</pre><img vspace="5" hspace="5" src="UnsupervisedScript_12.png" style="width:560px;height:420px;" alt=""> <h2>How much uptime did we gain?<a name="21"></a></h2><p>If we were to use this method in place of our regularly scheduled maintenance, how many additional cycles of operation would we gain? Here we look at how many cycles we would gain if we either performed maintenance as soon as the warn signal is generated, or waited and performed maintenance once an alarm is triggered.</p><p>This data was published by NASA and they curated it to start fairly close to failure, so some of these percentages may be high compared to other applications. However the general outcome tends to be the same. Usually there is a conservative strategy (such as maintenance on warning) that may give us a small percentage boost over scheduled maintenance, a more aggresive strategy (maintenance on alarm) that will give us more, and then a maximum amount we could gain if we did maintenance one sample prior to failure.</p><pre class="codeinput"><span class="comment">% group by unit</span>
ge = findgroups(fullDataset.Unit);
<span class="comment">% find the first time a warning or alarm was triggered for each engine</span>
sw = splitapply(@(x,y) min(x(y)),fullDataset.Time,idxWarn,ge);
sa = splitapply(@(x,y) min(x(y)),fullDataset.Time,idxAlarm,ge);
<span class="comment">% number of cycles we get with default maintenance</span>
defaultCycles = 125*100; <span class="comment">% 125 cycles before maintenance * 100 engines</span>
<span class="comment">% number of cycles gained by performing maintenance as soon as warning or</span>
<span class="comment">% alarm signals triggered</span>
gainedCyclesWarn = sum(sw)-defaultCycles;
gainedCyclesAlarm = sum(sa)-defaultCycles;
fprintf(<span class="string">'\nGain %.1f%% additional uptime by doing maintenance upon first Warning signal.\n'</span>,gainedCyclesWarn/defaultCycles*100)
fprintf(<span class="string">'Gain %.1f%% additional uptime by doing maintenance upon first Alarm signal.\n'</span>,gainedCyclesAlarm/defaultCycles*100)
maxCycles = length(idxAlarm) - defaultCycles - 100;
fprintf(<span class="string">'Gain %.1f%% additional uptime by doing maintenance 1 sample before failure.\n'</span>,maxCycles/defaultCycles*100)
<span class="comment">% have any engines not triggered an alarm at any point?</span>
sna = splitapply(@(x) any(idxAlarm),idxAlarm,ge);
numalarmed = sum(sna == 0);
fprintf(<span class="string">'Number of engines that did NOT trigger an alarm before failing: %.0f\n'</span>,numalarmed)
</pre><pre class="codeoutput">
Gain 1.9% additional uptime by doing maintenance upon first Warning signal.
Gain 38.4% additional uptime by doing maintenance upon first Alarm signal.
Gain 60.2% additional uptime by doing maintenance 1 sample before failure.
Number of engines that did NOT trigger an alarm before failing: 0
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2016a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Unsupervised Analysis for Predictive Maintenance
% One common situation is when our equipment maintenance schedule is very
% conservative, resulting in none of the equipment experiencing failures.
% Many organizations may choose this approach if failures are particularly
% costly, but this can often lead to waste as maintenance may be performed
% more often than required. If we do not have real-world data for what
% failure looks like, then we have 2 options:
%
% * Create a high fidelity model and inject failures to gather data,
% potentially for use in a supervised learning workflow
% * Use unsupervised learning on the data to create a warning system for
% when behavior is deviating from normal
%
% This script focuses on the second option.

%% Story setup
% We've acquired a fleet of 100 aircraft engines. The manufacturer
% recommends that we perform maintenace after every 125 flights. After our
% first round of maintenance, our maintenance workers tell us that only
% engines 39, 57, 70, and 91 were badly in need of maintenance. The others
% seemed fine and could have run longer without servicing. This means we
% are wasting money by doing maintenance more often than needed. We'd like
% to develop a better way to identify when servicing is needed so we can be
% smarter about scheduling our maintenance.

%% Read in first engine data
% The data used is the sensor readings taken off of the equipment.
% Maintenance was done after 125 flights, regardless of whether the
% equipment seemed to need it or not, so we only have the first 125 flights
% off of each engine. We have data from 100 engines, each stored in a
% separate file. We'll start by looking at just one data file for engine 1.

% read in data
sensorData = readtable('engine1Unsupervised.csv','ReadVariableNames',true);

%% View subset of sensor signals
% We have a total 21 sensors for each engine. Since that's a lot to put on
% the screen at once, let's look at just the first nine sensors. We can see
% that some of them are flat, so they won't be useful for understanding how
% the condition of the system is changing. Others need a bit of smoothing
% to remove some noise. The other 12 sensors we are not looking at here
% behave similarly.

figure
for ii = 1:9
    subplot(3,3,ii)
    plot(sensorData.Time,sensorData{:,5+ii})
    title(sensorData.Properties.VariableNames{5+ii})
    xlabel('Time')
    xlim([0,125])
end

%% Select relevant variable names based on visualization
% Here we select the variables we want to keep, getting rid of the sensors
% that were flat and unuseful.
variableNames = {'Unit' 'Time' 'LPCOutletTemp' 'HPCOutletTemp' ...
    'LPTOutletTemp' 'TotalHPCOutletPres' 'PhysFanSpeed' ...
    'PhysCoreSpeed' 'StaticHPCOutletPres' 'FuelFlowRatio'...
    'CorrFanSpeed' 'CorrCoreSpeed' 'BypassRatio'...
    'BleedEnthalpy' 'HPTCoolantBleed' 'LPTCoolantBleed'};
sensorData = sensorData(:, variableNames);

%% Remove noise
% There is some amount of noise in the signal. There are many advanced
% methods in MATLAB to identify and remove noise. Here we simply use a
% trailing moving average filter to smooth the signals slightly.

% Filter configuration
filterWindow = 5;
b = (1/filterWindow)*ones(1,filterWindow);
a = 1;
% Filter sensor data
smoothData = sensorData;
smoothData{:,3:end} = filter(b,a,sensorData{:,3:end});
smoothData(1:5,:) = [];

%% Plot smoothed data
% We are down to 14 sensors from 21 after removing the sensors that were
% constant signals. After smoothing the remaining signals, we can now see
% the signals we have to work with.

figure
for ii = 1:9
    subplot(3,3,ii)
    plot(smoothData.Time,smoothData{:,5+ii})
    title(smoothData.Properties.VariableNames{5+ii})
    xlabel('Time')
    xlim([0,125])
end

%% Monitoring equipment - control charts
% How can we use these signals to determine if the equipment is in normal
% coniditions? One common method is using what is called a control chart.
% As long as our signal stays within the upper and lower control limits, we
% might consider it normal conditions. If the signals goes outside the
% limits, then we might have a problem.
%
% However when we have a large number of signals, such as the 14 we have
% here, it is difficult to determine when we might have a problem. Is one
% sensor going outside the bounds for 1 point a problem? 5 sensors for 3
% points? 10 sensors for 20 points? Control charts become difficult to use
% in these cases, so we will bring in machine learning to help us.

controlchart(sensorData.LPCOutletTemp,'chart','i')

%% Read all data
% Before we try using machine learning, let's read in all the data we have
% available. Our data files are stored in a single folder, with each of the
% hundred engines stored in a separate file. We will use a datastore to
% easily read them all in.

% enter the file names with wildcard character * or ?
filenames = 'train_FD001_Unit_*';
files = [pwd '\Data\' filenames '.csv'];
% set up the data store
ds = datastore(files,'TreatAsMissing','NA','Delimiter', ',',...
    'SelectedVariableNames',variableNames,'ReadSize','file');
% read all the data from the datastore
dataAll = readall(ds);
% apply the moving average filter one engine at a time
smoothDataAll = filterData(b,a,dataAll,125);

%% Plot all data
% Now we can visualize all 100 engines plotted on top of each other. We can
% now see that there is not a clear signal over time, but rather a range of
% values that the sensors could take.

figure
for ii = 1:9
    subplot(3,3,ii)
    plot(smoothDataAll.Time,smoothDataAll{:,5+ii},'.')
    title(smoothDataAll.Properties.VariableNames{5+ii})
    xlabel('Time')
    xlim([0,125])
end

%% Standardize data
% Many machine learning techniques, such as PCA, involve measuring
% distances between points. However machine learning algorithms do not
% understand concepts like units. Since the data is recorded with different
% scales and units we need to standardize the data in some way. There are
% many different ways we might standardize data based on its properties and
% our analysis goals. Just as one example, here we give each signal the
% same mean of zero and standard deviation of one.

% Pull out just the sensor data, ignoring the unit and timestamp
Xtrain = smoothDataAll{:,3:end};
% Give all sensors mean of zero and standard deviation of one
XtrainMean = mean(Xtrain);
XtrainStd = std(Xtrain);
XtrainStandard = (Xtrain - repmat(XtrainMean,length(Xtrain),1))./...
    repmat(XtrainStd,length(Xtrain),1);

%% Dimensionality Reduction - PCA
% Principal component analysis (PCA) is one of the most popular methods of
% reducing the dimensionality of the data by rotating our axes such that
% they point in the directions of maximum variance. This allows us to
% summarize a large portion of the data in a smaller dimensional data set.
% In this case, note that the first two principal components capture a good
% portion of the variance in the dataset but further principal components
% only capture a small amount of additional information.

% apply principal components analysis to the standardized data
[coeff,score,latent] = pca(XtrainStandard);

% plot the total variance explained by each individual principal component
% along with the cumulative total that has been explained
figure
plot([cumsum(latent(1:10))/sum(latent) latent(1:10)/sum(latent)]*100,'.',...
    'MarkerSize',18)
xlabel('# of principal component');
ylabel('% of variance of dataset explained');
legend('Cumulative','Individual')
title('Individual and Cumulative Variance Explained by PCA')
grid on

% visualize the first 2 principal components, which explain nearly 90% of
% the overall variance
figure
plot(score(:,1),score(:,2),'.')
xlabel('First Principal Component')
ylabel('Second Principal Component')

% Save the needed variables to standardize new data and transform it into
% the same PCA projection
save cordTrans coeff XtrainMean XtrainStd

%% What do higher principal components look like?
% In this case the higher principal components only contain a very small
% amount of information. If we project our data onto the third and fourth
% principal components, as seen below, it looks like they contain only
% normally distributed random noise. This holds true for all higher
% principal components as well. 

figure
scatter(score(:,3),score(:,4));
xlabel('Third Principal Component')
ylabel('Fourth Principal Component')
title('4th vs 3rd Principal Component')

%% Warning system
% Now we need to find some way to use this group of points to determine
% when conditions are deviating away from 'normal'. A common approach is to
% call the region that contains densely packed points 'normal' conditions,
% and the small number of points that fall outside of them to be 'abnormal'
% and potentially in need of maintenance. We need some way to determine
% when an engine might transition from 'normal' to 'abnormal' behavior.

%% Visualize first and last points for each engine
% As a first try we can simply look at the first and last point recorded
% for each engine. If engines tend to start in a certain area of the PCA,
% but move to a different area by the time maintenance is performed, this
% may give us some indication of what the trend towards failure looks like.
%
% In this case we can see that the first and last points form two groups,
% with the first points centered closer to the origin and the last points
% centered further away. However there is significant overlap between them,
% which would not be surprising if many engines are still behaving normally
% at the time maintenance was performed.

%%

% Find first and last point for each engine
[~,idxEng] = unique(smoothDataAll.Unit);
idxEngLast = idxEng-1;
idxEngLast(idxEngLast < 1) = [];

% Compute centroids
idxEngCent = [mean(score(idxEng,1)),mean(score(idxEng,2))];
idxEngLastCent = [mean(score(idxEngLast,1)),mean(score(idxEngLast,2))];

% Plot data
figure; hold on
plot(score(idxEng,1),score(idxEng,2),'.','MarkerSize',16)
plot(score(idxEngLast,1),score(idxEngLast,2),'r.','MarkerSize',16)
scatter(idxEngCent(1),idxEngCent(2),50,'g','^','filled')
scatter(idxEngLastCent(1),idxEngLastCent(2),50,'g','o','filled')
hold off
legend('First Points','Last Points','First Points Centroid',...
    'Last Points Centroid','Location','NorthWest')
xlabel('First Principal Component')
ylabel('Second Principal Component')
title('First (Sample 1) and Last (Sample 125) for Each Engine')

%% Highlight problematic engines
% The prior plot showed much overlap between the first and last data
% points. However some of the last data points clearly fall well outside
% the main cluster. Our maintenance staff identified several engines that
% had showed signs of degredation. Here we can show the points just from
% these engines as they approach their maintenance date to see if they show
% any clear trends. They are plotted on top of all other points to see how
% they may be different.
%
% We can see that many of them do indeed fall outside the main cluster of
% points, indicating that if an engine's sensor readings move outside the
% main cluster it may make for a good criteria for when an engine needs
% servicing.

idx = ismember(smoothDataAll.Unit,[39, 57, 70, 91]);
idx = idx & smoothDataAll.Time > (max(smoothDataAll.Time)-20); % only last 20 cycles
figure; hold on;
plot(score(:,1),score(:,2),'.')
plot(score(idx,1),score(idx,2),'r.')
hold off
xlabel('First Principal Component')
ylabel('Second Principal Component')
title('Last 20 Flights of Problematic Engines Shown in Red')

%% Animation of path through PCA
% For further investigation we can see how different engines move through
% the cluster of data points as they approach their maintenance date.

% Engines identified by maintenance: [39, 57, 70, 91]
EngineNum = 39;
r = find(smoothDataAll.Unit == EngineNum);
figure; hold on
pall = plot(score(:,1),score(:,2),'.');
peng = plot(score(r(1),1), score(r(1),2),'g-','LineWidth',2);
pcur = plot(score(r(1),1), score(r(1),2),'go','MarkerFaceColor','r');
ti = title(['Engine ' num2str(EngineNum) ' Sample 1']);
xlabel('First Principal Component')
ylabel('Second Principal Component')
hold off
for ii = 1:length(r)
    set(peng,'XData',score(r(1:ii),1),'YData',score(r(1:ii),2))
    set(pcur,'XData',score(r(ii),1),'YData',score(r(ii),2))
    ti.String = ['Engine Number ' num2str(EngineNum) ' Sample ' num2str(ii+4)];
    pause(0.1)
end

%% Initial criteria for warning and alarm signals
% Based on the results, we can make an initial guess for the criteria to
% use for when to issue a 'warning' or 'alarm' signal. Clearly all engines
% begin within the main cluster of points. It seems that they may move
% outside of the cluster as servicing becomes more needed. We will generate
% a 'warn' result when the engine behavior has left 'normal' conditions (in
% this case 'normal' includes about 90% of the data) and should be
% prioritized for maintenance. An 'alarm' means that this engine is very
% far from 'normal' and may need maintenance urgently. Below is one example
% of an initial guess we may make for where to draw the line between the
% 'normal', 'warn', and 'alarm' regions.
%
% The criteria for producing the 'warn' and 'alarm' signals should be
% treated as initial guesses that will continue to evolve over time as we
% perform more rounds of maintenance while gathering more sensor data and
% maintenance feedback.

idxAlarm = score(:,1) > 10 | score(:,1) < -7 | score(:,2) > 5 | score(:,2) < -4;
idxWarn = score(:,1) > 5 | score(:,1) < -6.5 | score(:,2) > 2 | score(:,2) < -3 ...
    & ~idxAlarm;

figure; hold on
patch([-10;-10;15;15;10;10;-7;-7;-10],...
    [-4,8,8,-4,-4,5,5,-4,-4],'r','FaceAlpha',0.3)
patch([-7,-7,10,10,5,5,-6.5,-6.5,4.99,4.99,-6.5],...
    [-4,5,5,-4,-4,2,2,-3,-3,-4,-4],'y','FaceColor',[1 .8 0],'FaceAlpha',0.3)
patch([-6.5,-6.5,5,5,-6.5],[-3,2,2,-3,-3],'g','FaceAlpha',0.3)
plot(score(:,1),score(:,2),'.')
hold off
title('Green = Normal, Orange = Warning, Red = Alarm')
xlabel('First Principal Component')
ylabel('Second Principal Component')

fprintf('\nPercent of points captured by ''normal'' conditions: %.1f%% \n',sum(~idxWarn)/length(score)*100)
fprintf('Percent of points captured by ''normal'' + ''warn'' conditions: %.1f%% \n',sum(~idxAlarm)/length(score)*100)

%% How can we evaluate the criteria?
% Since we have never had an equipment failure, we have no way of knowing
% what failure looks like in the data. Even though our maintenance staff
% identified several engines that appeared to be degrading, and those
% engines appeared to show a distinct trend closer to the maintenance date,
% we still don't know how close to failure they actually were. So then how
% can we use this information to improve our decision making? This is one
% of the most difficult aspects of unsupervised learning.
%
% There are a number of strategies for how to use these results. One
% conservative strategy is to slowly roll back the regularly scheduled
% maintenance dates. For example, this data came from our first round of
% maintenance. On the next maintenance round, we might wait to perform
% maintenance until equipment cycle 135 instead of 125, unless a piece of
% equipment signals an 'alarm'. If it does, we could prioritize maintenance
% for that piece of equipment. Otherwise, we will wait longer than the last
% time to do scheduled maintenance. Along the way we can use the additional
% sensor data and feedback from maintenance to update our 'warn' and
% 'alarm' criteria.
%
% We can continue to roll back the pace of our regularly scheduled
% maintenance dates, until we are scheduling our maintenance entirely based
% on when we get the 'warn' and 'alarm' signals from our equipment. If a
% failure does occur in spite of our efforts, SAVE THAT DATA! Real world
% data leading up to and including failure is both very valuable and very
% expensive to gather. The better we can understand what failure looks like
% in the data, the better our results can get.

%% Evaluate all engines to failure
% We actually do have data from all 100 engines running until failure
% conditions are reached, we were just ignoring what happened after sample
% 125 so we could explore an unsupervised workflow in a scheduled
% maintenance situation. Here we load in all the data from all 100 engines
% to determine how this would have turned out if we ran all our engines to
% failure while tracking their warning and alarm signals. 
%
% We can see how as the engines approach failure the ratios of 'normal',
% 'warning' and 'alarm' classifications change over time. All engines are
% 'normal' until around 125 flights prior to failure, at which point some
% begin to enter the 'warning' region. Around 75 flights prior to failure,
% some befin to enter the 'alarm' region. All engines have left 'normal'
% conditions by 26 flights prior to failure. By 9 flights prior to failure,
% all 100 engines are triggering alarms, so no engine enters failure
% without triggering an alarm for at least 9 consecutive flights.

% load in full dataset
load fullDataset
load cordTrans
% extract and standardize full sensor data
Xfull = fullDataset{:,3:end-2};
Xfull = (Xfull - repmat(XtrainMean,length(Xfull),1))./repmat(XtrainStd,length(Xfull),1);
% project full sensor data onto principal coordinates
score = Xfull*coeff;
% classify each point into 'normal', 'warning', and 'alarm'
idxAlarm = score(:,1) > 10 | score(:,1) < -7 | score(:,2) > 5 | score(:,2) < -4;
idxWarn = (score(:,1) > 5 | score(:,1) < -6.5 | score(:,2) > 2 | score(:,2) < -3) & ~idxAlarm;
idxNorm = ~idxWarn & ~idxAlarm;
% group by time before failure, and determine which percentage of the
% engines were being classified into each group at each point in time
[g,r] = findgroups(fullDataset.Time2);
s = splitapply(@(n,w,a)[sum(n)/length(n),sum(w)/length(w),sum(a)/length(a)],idxNorm,idxWarn,idxAlarm,g);
% plot data
figure
hold on
plot(r,s(:,1),'g','LineWidth',2)
plot(r,s(:,2),'Color',[1 .8 0],'LineWidth',2)
plot(r,s(:,3),'r','LineWidth',2)
legend('Normal','Warning','Alarm','Location','NorthWest')
xlabel('Flights Prior to Failure')
ylabel('Fraction of Engines')
grid on
hold off

%% How much uptime did we gain?
% If we were to use this method in place of our regularly scheduled
% maintenance, how many additional cycles of operation would we gain? Here
% we look at how many cycles we would gain if we either performed
% maintenance as soon as the warn signal is generated, or waited and
% performed maintenance once an alarm is triggered.
%
% This data was published by NASA and they curated it to start fairly close
% to failure, so some of these percentages may be high compared to other
% applications. However the general outcome tends to be the same. Usually
% there is a conservative strategy (such as maintenance on warning) that
% may give us a small percentage boost over scheduled maintenance, a more
% aggresive strategy (maintenance on alarm) that will give us more, and
% then a maximum amount we could gain if we did maintenance one sample
% prior to failure.

% group by unit
ge = findgroups(fullDataset.Unit);
% find the first time a warning or alarm was triggered for each engine
sw = splitapply(@(x,y) min(x(y)),fullDataset.Time,idxWarn,ge);
sa = splitapply(@(x,y) min(x(y)),fullDataset.Time,idxAlarm,ge);
% number of cycles we get with default maintenance
defaultCycles = 125*100; % 125 cycles before maintenance * 100 engines
% number of cycles gained by performing maintenance as soon as warning or
% alarm signals triggered
gainedCyclesWarn = sum(sw)-defaultCycles;
gainedCyclesAlarm = sum(sa)-defaultCycles;
fprintf('\nGain %.1f%% additional uptime by doing maintenance upon first Warning signal.\n',gainedCyclesWarn/defaultCycles*100)
fprintf('Gain %.1f%% additional uptime by doing maintenance upon first Alarm signal.\n',gainedCyclesAlarm/defaultCycles*100)
maxCycles = length(idxAlarm) - defaultCycles - 100;
fprintf('Gain %.1f%% additional uptime by doing maintenance 1 sample before failure.\n',maxCycles/defaultCycles*100)
% have any engines not triggered an alarm at any point?
sna = splitapply(@(x) any(idxAlarm),idxAlarm,ge);
numalarmed = sum(sna == 0);
fprintf('Number of engines that did NOT trigger an alarm before failing: %.0f\n',numalarmed)

##### SOURCE END #####
--></body></html>